<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java-IO(上) BIO、NIO、AIO介绍</title>
    <url>/blog/2019/10/12/Java-IO-1/</url>
    <content><![CDATA[<h1 id="在开始之前"><a href="#在开始之前" class="headerlink" title="在开始之前"></a>在开始之前</h1><h2 id="这个系列的概要"><a href="#这个系列的概要" class="headerlink" title="这个系列的概要"></a>这个系列的概要</h2><p>这个系列主要是讲Java-IO，分为上中下三篇。</p>
<ol>
<li>上篇主要是介绍Java原生的<strong>BIO(IO),NIO,AIO(NIO2)</strong></li>
<li>中篇主要是介绍经典的IO框架<strong>Netty</strong>的基本概念，以及线程模型</li>
<li>下篇则是讲<strong>Netty</strong>的项目实践，如何用<strong>Netty</strong>实现一套<strong>RPC</strong>框架</li>
</ol>
<a id="more"></a>

<h2 id="关于源码"><a href="#关于源码" class="headerlink" title="关于源码"></a>关于源码</h2><p>在介绍Java原生IO，以及Netty框架的时候，我都会以一个简单的HttpServer作为Demo。<br>所以在本系列中会包含四个版本的HttpServer（BIO，NIO，AIO，Netty）。<br>其中BIO，NIO，AIO版本的Demo未引入任何第三方包，只需要JDK8+即可运行。<br>Netty版本的Demo需要配置第三方依赖，对应的maven配置在中篇会单独列出。</p>
<hr>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>本篇主要是对Java原生IO（BIO、NIO、AIO）进行介绍，同时进行对比。<br>为了给大家一个直观快速的感受，我们分别用这几种不同的IO方式，来写一个简单的HttpServer，这个HttpServer的主要功能就是，将浏览器的请求内容，原封不动的返回给浏览器。可能代码里面的部分API大家可能已经忘记了，不过不要紧，后面会对比较重要的部分进行详细的讲解。</p>
<h2 id="BIO版本HttpServer"><a href="#BIO版本HttpServer" class="headerlink" title="BIO版本HttpServer"></a>BIO版本HttpServer</h2><p>Java的BIO（IO）很简单，直接面向socket编程，每当接收到一个新的socket，都新建一个线程进行处理。当然了，处理线程也可以设计成线程池，可以在一定程度上提高性能。</p>
<img src="/blog/2019/10/12/Java-IO-1/1-Java-bio-thread.png" class="" title="BIO线程模型">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 用一个线程池处理接收到的请求</span></span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 服务端开启8081端口</span></span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8081</span>);</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">      <span class="comment">// 阻塞式接收请求</span></span><br><span class="line">      <span class="keyword">final</span> Socket accept = serverSocket.accept();</span><br><span class="line">      <span class="comment">// 每当有新的请求到来，将其放到线程池中处理</span></span><br><span class="line">      executor.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = accept.getInputStream();</span><br><span class="line">            BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(accept.getOutputStream()))) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 从inputStream中读取输入内容</span></span><br><span class="line">          <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">          inputStream.read(bytes);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 封装输出内容，并将其写到outputStream</span></span><br><span class="line">          writer.write(ResponseUtils.getResponse(<span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8)));</span><br><span class="line">          writer.flush();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里需要分别关闭输入和输出，否则浏览器请求的时候会发生异常</span></span><br><span class="line">          <span class="comment">// 思考1：为什么不能直接close</span></span><br><span class="line">          accept.shutdownInput();</span><br><span class="line">          accept.shutdownOutput();</span><br><span class="line">          accept.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <h5 id="思考一，shutdownInput，shutdownOutput-的作用是什么？"><a href="#思考一，shutdownInput，shutdownOutput-的作用是什么？" class="headerlink" title="思考一，shutdownInput，shutdownOutput 的作用是什么？"></a>思考一，shutdownInput，shutdownOutput 的作用是什么？</h5><p>因为socket是双向的，需要先关闭输入流，告诉客户端，我不再接收数据，然后关闭输出流，表示我的数据已经发送完毕。<br>详细信息可以参考如下<a href="https://blog.csdn.net/dabing69221/article/details/17351881" target="_blank" rel="noopener">【Java TCP/IP Socket】 — close()/shutdownOutput()/shutdownInput() 分析</a></p>
          </div>

<h2 id="NIO版本HttpServer"><a href="#NIO版本HttpServer" class="headerlink" title="NIO版本HttpServer"></a>NIO版本HttpServer</h2><p>NIO是本章重点介绍内用，因为是对后续的Netty框架介绍做铺垫，所以这里会讨论以下内容：</p>
<ol>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
<li>为什么用NIO</li>
</ol>
<img src="/blog/2019/10/12/Java-IO-1/2-Java-nio-thread.png" class="" title="NIO线程模型">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 全局selector，至关重要</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 服务端开启对8082端口的监听</span></span><br><span class="line">    ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8082</span>));</span><br><span class="line">    <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">    <span class="comment">// 思考1：阻塞和同步是一个概念吗？非阻塞=异步？</span></span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 注册监听到selector上</span></span><br><span class="line">    ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">      <span class="comment">// 因为是非阻塞模式，所以不论是否接收到请求，selector.select()都会立即返回。这里需要判断是否真正的accept</span></span><br><span class="line">      <span class="keyword">if</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理接收到的事件</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          SelectionKey key = iterator.next();</span><br><span class="line">          iterator.remove();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();</span><br><span class="line">            SocketChannel channel = serverSocketChannel.accept();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册读事件</span></span><br><span class="line">            channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 我们不会直接从channel中取出字节，而是将channel中的数据写入Buffer缓冲区</span></span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer result = ByteBuffer.allocate(<span class="number">102400</span>);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">while</span> (sc.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 从buffer读数据之前，进行flip操作。</span></span><br><span class="line">              <span class="comment">// 思考2：为什么从buffer读数据要先进行flip操作</span></span><br><span class="line">              buffer.flip();</span><br><span class="line">              result.put(buffer);</span><br><span class="line">              <span class="comment">// 思考3：为什么向buffer写数据要先进行clear操作(新建的buffer不需要)</span></span><br><span class="line">              buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续注册写事件</span></span><br><span class="line">            sc.register(selector, SelectionKey.OP_WRITE, <span class="keyword">new</span> String(result.array(), StandardCharsets.UTF_8));</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">            SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">            String attachment = (String) key.attachment();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(ResponseUtils.getResponse(attachment).getBytes());</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">              sc.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回写数据完成，关闭channel</span></span><br><span class="line">            sc.close();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <h5 id="思考1：阻塞和同步是一个概念吗？非阻塞-异步？"><a href="#思考1：阻塞和同步是一个概念吗？非阻塞-异步？" class="headerlink" title="思考1：阻塞和同步是一个概念吗？非阻塞=异步？"></a>思考1：阻塞和同步是一个概念吗？非阻塞=异步？</h5><p>这种概念性的问题没必要太关注，有点像回字有多少种写法，关键的还是要能够理解IO模型的原理。<br>这里只是简单提一下。通过<a href="https://samforit.github.io/blog/2019/11/02/Unix-IO/">Unix的五种IO模型介绍</a> 我们可以知道：<br>1.BIO是阻塞式IO，是同步IO，这点是没有异议的<br>2.NIO可以设置两种模式：阻塞模式（Unix多路复用IO）和非阻塞模式（Unix非阻塞IO），但数据从内核态加载为用户态的这个过程，是同步的，所以NIO也是同步的。<br>3.AIO(后面会进行讨论)是完全的非阻塞模式，也是真正的异步IO。<br>综上：<br>非阻塞，对于底层Unix-IO模型，都是指数据从磁盘加载到内核态的这个过程，是否阻塞。<br>异步是指整个IO操作（包含了两步：数据在内核态准备完成，数据从内核态转变为用户态）完成之后，系统通知应用程序（通过signal或callback）。</p>
          </div>


<div class="note info">
            <h5 id="思考2：为什么从buffer读数据要先进行flip操作"><a href="#思考2：为什么从buffer读数据要先进行flip操作" class="headerlink" title="思考2：为什么从buffer读数据要先进行flip操作"></a>思考2：为什么从buffer读数据要先进行flip操作</h5><p>buffer底层就是一个数组，我们需要当写数据的时候我们需要记录从何处开始写（position），以及数组的最大容量（capacity）。<br>当我们读数据的时候，需要知道当前数组有多少个元素可读（limit），以及记录当前已经读到了哪个位置（position）。<br>所以当读写模式转换的时候，我们就需要对buffer进行flip（写转读），clear（读转写）操作。详见【NIO Buffer】章节<br>以上只是一般性操作，不代表所有应用场景。</p>
          </div>


<div class="note info">
            <h5 id="思考3：为什么向buffer写数据要先进行clear操作-新建的buffer不需要"><a href="#思考3：为什么向buffer写数据要先进行clear操作-新建的buffer不需要" class="headerlink" title="思考3：为什么向buffer写数据要先进行clear操作(新建的buffer不需要)"></a>思考3：为什么向buffer写数据要先进行clear操作(新建的buffer不需要)</h5><p>同思考2</p>
          </div>

<h3 id="NIO-Channel"><a href="#NIO-Channel" class="headerlink" title="NIO Channel"></a>NIO Channel</h3><img src="/blog/2019/10/12/Java-IO-1/2-nio-channel.png" class="" title="NIO-Channel读写模型">
<p>channel在NIO中的地位，和流在BIO中的地位类似。但有以下不同点：</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>Channel</th>
<th>流（InputStream，OutputStream）</th>
</tr>
</thead>
<tbody><tr>
<td>方向</td>
<td>双向的</td>
<td>一般来说都是单向的</td>
</tr>
<tr>
<td>异步</td>
<td>支持异步操作【AIO就是典型的例子】</td>
<td>只支持同步操作</td>
</tr>
<tr>
<td>对接</td>
<td>一般不能直接从channel读写数据，channel只和缓冲区Buffer交互</td>
<td>直接对流进行读写</td>
</tr>
</tbody></table>
<h3 id="NIO-Buffer"><a href="#NIO-Buffer" class="headerlink" title="NIO Buffer"></a>NIO Buffer</h3><img src="/blog/2019/10/12/Java-IO-1/2-nio-buffers-modes.png" class="" title="NIO-Buffer读写模型">

<table>
<thead>
<tr>
<th></th>
<th>向缓冲区写数据时</th>
<th>从缓冲区读数据时</th>
</tr>
</thead>
<tbody><tr>
<td><strong>position</strong></td>
<td>记录当前已经在buffer中写入了多少数据，指向下一个即将写入数据的坑位。举例，如果当前从缓冲区读取7个元素，则当前缓冲区的position的值为7，指向第8个元素的位置。</td>
<td>记录当前从buffer中读取了多少数据，指向下一个即将读取的元素。举例，如果当前已经从缓冲区读取了4个元素，那么缓冲区的position将被设置为4，指向第5个元素。</td>
</tr>
<tr>
<td><strong>limit</strong></td>
<td>一般来说limit等于capacity。</td>
<td>记录最后一个可读取元素的位置。</td>
</tr>
<tr>
<td><strong>capacity</strong></td>
<td>表示缓冲区的最大容量。</td>
<td>表示缓冲区的最大容量。</td>
</tr>
</tbody></table>
<p>有一篇文章对buffer内部结构的介绍很详细，可以参考：<a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM-NIO入门</a></p>
<h3 id="NIO-Selector"><a href="#NIO-Selector" class="headerlink" title="NIO Selector"></a>NIO Selector</h3><img src="/blog/2019/10/12/Java-IO-1/2-Java-nio-thread.png" class="" title="selector模型">

<p>Selector基于操作系统底层的epoll，一个Selector可以同时监听多个Channel上的事件，不必对每一个连接都新建一个线程。</p>
<div class="note danger">
            <h3 id="为什么使用NIO"><a href="#为什么使用NIO" class="headerlink" title="为什么使用NIO"></a>为什么使用NIO</h3><p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。<br>NIO的出现，使得当IO未就绪时，线程可以不挂起，继续处理其他事情。一个线程也不必局限于只为一个IO连接服务。</p>
          </div>

<p>BIO与NIO的线程模型对比：</p>
<table>
<thead>
<tr>
<th><strong>BIO模型</strong></th>
<th><strong>NIO模型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><img src="/blog/2019/10/12/Java-IO-1/nio-vs-io-1.png" class="" title="BIO线程"></td>
<td><img src="/blog/2019/10/12/Java-IO-1/nio-vs-io-2.png" class="" title="NIO线程"></td>
</tr>
<tr>
<td>IO以流的方式处理数据</td>
<td>NIO 以块的方式处理数据</td>
</tr>
<tr>
<td>面向流的IO系统一次一个字节地处理数据，通过过滤器，处理流程很优雅</td>
<td>每一个操作都在一步中产生或者消费一个数据块，缺少流式处理的优雅性与简单性</td>
</tr>
<tr>
<td>面向流的IO通常相当慢</td>
<td>按块处理数据比按流处理要快得多</td>
</tr>
</tbody></table>
<h2 id="AIO版本HttpServer"><a href="#AIO版本HttpServer" class="headerlink" title="AIO版本HttpServer"></a>AIO版本HttpServer</h2><p>应用程序完全不用关心IO何时准备好，这一切都交给操作系统（IO的两个阶段）。<br>同时给操作系统提供一个缓冲区，当数据往缓冲区写好之后，通知应用程序即可。</p>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 服务端启动8083端口</span></span><br><span class="line">    <span class="keyword">final</span> AsynchronousServerSocketChannel channel = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8083</span>));</span><br><span class="line">    channel.accept(channel, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(<span class="keyword">final</span> AsynchronousSocketChannel client, AsynchronousServerSocketChannel attachment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 思考1：accept again，why？</span></span><br><span class="line">        attachment.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配一块缓冲区，将客户端的数据写入缓冲区中。</span></span><br><span class="line">        <span class="comment">// 思考2：这样有什么缺点</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        client.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result_num, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 准备冲缓冲区读数据，老规矩，先进行flip</span></span><br><span class="line">            attachment.flip();</span><br><span class="line">            <span class="keyword">byte</span>[] body = <span class="keyword">new</span> <span class="keyword">byte</span>[attachment.remaining()];</span><br><span class="line">            attachment.get(body);</span><br><span class="line">            String response = ResponseUtils.getResponse(<span class="keyword">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class="line">            ByteBuffer writeBuffer = ByteBuffer.wrap(response.getBytes());</span><br><span class="line">            <span class="comment">// 数据回写</span></span><br><span class="line">            client.write(writeBuffer, writeBuffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 回写数据完成，关闭连接</span></span><br><span class="line">                  client.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;<span class="comment">/** write fail 咋办 */</span>&#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;<span class="comment">/** read fail 咋办 */</span>&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, AsynchronousServerSocketChannel attachment)</span> </span>&#123;<span class="comment">/** accept fail 咋办 */</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 思考3：这行代码的必要性</span></span><br><span class="line">    System.in.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <h5 id="思考1：accept-again，why？"><a href="#思考1：accept-again，why？" class="headerlink" title="思考1：accept again，why？"></a>思考1：accept again，why？</h5><p>因为AIO是异步模型，当接收到请求之后，当前线程就退出了，所以当接收到请求之后，需要再次注册服务端的accept操作。</p>
          </div>

<div class="note info">
            <h5 id="思考2：read数据之前，先分配缓冲区，这样有什么缺点"><a href="#思考2：read数据之前，先分配缓冲区，这样有什么缺点" class="headerlink" title="思考2：read数据之前，先分配缓冲区，这样有什么缺点"></a>思考2：read数据之前，先分配缓冲区，这样有什么缺点</h5><p>预分配缓冲区大小，需要按照最大请求的输入Body-size进行分配，所以对于一个Body比较小的请求，相当于资源浪费。</p>
          </div>

<div class="note info">
            <h5 id="追加思考：如果预分配的缓冲区大小不足以接收channel中的所有数据，怎么办？"><a href="#追加思考：如果预分配的缓冲区大小不足以接收channel中的所有数据，怎么办？" class="headerlink" title="追加思考：如果预分配的缓冲区大小不足以接收channel中的所有数据，怎么办？"></a>追加思考：如果预分配的缓冲区大小不足以接收channel中的所有数据，怎么办？</h5><p>数据在Channel中是顺序读取的，如果接收数据的Buffer空间，小于Channel中实际的数据内容，比如，现在Channel中有4个字节[a,b,c,d]，但现在接受缓冲区数据的Buffer大小只有3个字节。<br>此时，只会读取前Channel中的前三个字节[a,b,c]到Buffer中，剩余的一个字节[d]仍留在Channel中，如果继续从Channel中读数据，可以将第四个字节读出来。<br>最后：如果Channel中有数据未读取，当Channel关闭的时候，里面的数据就被丢弃了。<br>由此我们可以看出：<br>java.nio.channels.AsynchronousSocketChannel#read(java.nio.ByteBuffer, A, java.nio.channels.CompletionHandler&lt;java.lang.Integer,? super A&gt;)<br>这个方法，以下两种情况满足任意一种都会认为数据读取完成，从而回调completed方法：<br>1.channel中的所有数据都已经读到Buffer中。<br>2.Buffer的可用空间已经被填满。</p>
          </div>

<div class="note info">
            <h5 id="思考3：System-in-read-这行代码的必要性"><a href="#思考3：System-in-read-这行代码的必要性" class="headerlink" title="思考3：System.in.read(); 这行代码的必要性"></a>思考3：System.in.read(); 这行代码的必要性</h5><p>因为异步代码执行完成之后，线程就退出了，随之应用程序退出。<br>所以需要加上一行，主线程等待系统输入，避免程序退出。</p>
          </div>


<div class="note info">
            <h5 id="AIO看起来比NIO更高效，为什么Netty使用NIO而不是AIO？"><a href="#AIO看起来比NIO更高效，为什么Netty使用NIO而不是AIO？" class="headerlink" title="AIO看起来比NIO更高效，为什么Netty使用NIO而不是AIO？"></a>AIO看起来比NIO更高效，为什么Netty使用NIO而不是AIO？</h5><p>1.服务器大多是Linux系统，AIO的底层实现仍使用EPOLL，没有很好实现AIO，因此在性能上没有明显的优势。<br>2.AIO接收数据的时候需要预先分配缓冲区大小, 而不是NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 会造成内存浪费</p>
          </div>

<h2 id="以上代码中用到的工具类"><a href="#以上代码中用到的工具类" class="headerlink" title="以上代码中用到的工具类"></a>以上代码中用到的工具类</h2><p>主要就是封装Http-Header和Response</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CRLF = <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getResponse</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    msg = <span class="string">"Server response:&lt;br&gt;&lt;br&gt;"</span> + msg.replaceAll(CRLF, <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(<span class="string">"HTTP /1.1 200 ok "</span>).append(CRLF)</span><br><span class="line">        .append(<span class="string">"Content-Type:text/html "</span>).append(CRLF)</span><br><span class="line">        .append(<span class="string">"Content-Length:"</span> + msg.length()).append(CRLF).append(CRLF)</span><br><span class="line">        .append(msg).toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h1><p>没有比这个更简明易懂的NIO教程了<br><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO Tutorial</a></p>
<p>IBM讲NIO的Buffer比较详细<br><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">IBM-NIO入门</a></p>
<p>美团技术博客讲NIO的<br><a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener">Java NIO浅析</a></p>
<p>AIO讲解<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-nio2/index.html" target="_blank" rel="noopener">在 Java 7 中体会 NIO.2 异步执行的快乐</a></p>
]]></content>
      <categories>
        <category>IO</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix的五种IO模型介绍</title>
    <url>/blog/2019/10/11/Unix-IO/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前打算总结一下Java的<strong>BIO（IO），AIO，NIO</strong>，最后一步步深入，发现Unix（Linux）的IO模型需要提前掌握，所以先总结一下Unix的IO模型。</p>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Java-IO-与-Unix-IO-的关系（非严格对应）"><a href="#Java-IO-与-Unix-IO-的关系（非严格对应）" class="headerlink" title="Java IO 与 Unix IO 的关系（非严格对应）"></a>Java IO 与 Unix IO 的关系（非严格对应）</h2><p>Unix网络编程中介绍了五种IO模型，分别是：阻塞IO、非阻塞IO、IO多路复用、信号驱动IO、异步IO。<br>Java的IO模型与Unix的IO模型的对应关系如下所示（这个对应关系并不严格）：</p>
<table>
<thead>
<tr>
<th>Java-IO模型</th>
<th>Unix-IO模型</th>
</tr>
</thead>
<tbody><tr>
<td>BIO</td>
<td>阻塞式IO</td>
</tr>
<tr>
<td>NIO</td>
<td>IO多路复用</td>
</tr>
<tr>
<td>AIO</td>
<td>异步IO</td>
</tr>
</tbody></table>
<h2 id="数据的内核态和用户态"><a href="#数据的内核态和用户态" class="headerlink" title="数据的内核态和用户态"></a>数据的内核态和用户态</h2><img src="/blog/2019/10/11/Unix-IO/linux-kernal-user.png" class="" title="数据的内核态和用户态">
<p>在进行IO模型讲解之前，先讲讲数据的两个状态：内核态和用户态。<br>我们将文件从磁盘加载到内存中。操作系统是怎么做的？<br>第一步：因为我们的所有程序，都是和操作系统的内核进行交互，所以文件首先是从磁盘加载到内核，这时候文件是处于内核态。<br>第二步：文件从内核再加载到内存中，应用程序此时才可以在内存中进行读写操作。这个时候的文件就是内核态。<br>所以Unix的五种IO模型的不同指出，就是这两个步骤的处理流程不同。</p>
<h1 id="Unix五种IO模型分别介绍"><a href="#Unix五种IO模型分别介绍" class="headerlink" title="Unix五种IO模型分别介绍"></a>Unix五种IO模型分别介绍</h1><h2 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h2>
<p>这种模式很简单，系统给调用<strong>recvfrom</strong>函数之后，线程一直处于等待状态，一直等到：<br>第一步文件加载到内核态完成，第二步文件加载到用户态完成。</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2>
<p>系统不停的通过<strong>recvfrom</strong>进行轮询，一直到第一步完成，然后在第二步阻塞式的将数据从内核态加载到用户态。<br>这里的非阻塞IO模式，主要是指第一步，加载数据到内核态，这个过程是非阻塞的，通过轮询来判断数据是否在内核准备好。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2>
<p>系统首先通过select，阻塞式的查看内核数据是否准备完毕。<br>当内核数据加载完成之后，系统会调用<strong>recvfrom</strong>，将内核态的数据加载到用户态。<br>这里看起来第一步和第二步都是阻塞式操作，但是，select可以在极小代价的情况下，同时处理多个文件句柄（包括socket）。</p>
<h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2>
<p>第一步，相当于系统注册一个回调函数，当内核数据准备好了之后通知我。<br>此时系统可以做其他的事情，并不需要阻塞式的等待内核数据。<br>第二步，阻塞式调用<strong>recvfrom</strong>，将内核的数据加载到用户态。</p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><img src="/blog/2019/10/11/Unix-IO/5-AIO.jpg" class="" title="异步IO图示">
<p>这个模型在理论上来说，是真正的异步模型，因为在以上四种模型中，在第二步：数据从内核态加载到用户态，都是同步操作。<br>而在该模型中，系统在加载文件的时候，只需要通过aio_read注册一个回调，当文件完成了内核态，用户态的加载之后，通知当前系统。<br>在这个过程中，系统不用等待，可以执行其他的运算任务。</p>
<h2 id="汇总对比"><a href="#汇总对比" class="headerlink" title="汇总对比"></a>汇总对比</h2><img src="/blog/2019/10/11/Unix-IO/6-IO.jpg" class="" title="IO总览">
<p>这张图是对以上五种IO模型的汇总比较，总的来说，越靠后的模型在理论上来说就越高效。<br>前面的四种IO模型【阻塞IO、非阻塞IO、IO多路复用、信号驱动IO】，都属于同步IO，只有最后一种模型是真正的异步【异步IO】</p>
<h1 id="系统调用介绍"><a href="#系统调用介绍" class="headerlink" title="系统调用介绍"></a>系统调用介绍</h1><div class="note warning">
            <h3 id="1-Java的NIO老版本使用的是select模式，但后来改成了epoll，为什么？"><a href="#1-Java的NIO老版本使用的是select模式，但后来改成了epoll，为什么？" class="headerlink" title="1.Java的NIO老版本使用的是select模式，但后来改成了epoll，为什么？"></a>1.Java的NIO老版本使用的是select模式，但后来改成了epoll，为什么？</h3><p>因为select是轮询的模式，不停的检查文件句柄的状态。<br>epoll是callback的模式，当文件句柄准备好了之后，直接进行回调，更高效。</p>
          </div>

<div class="note warning">
            <h3 id="2-Java有真正的AIO模式吗？"><a href="#2-Java有真正的AIO模式吗？" class="headerlink" title="2.Java有真正的AIO模式吗？"></a>2.Java有真正的AIO模式吗？</h3><p>在Windows系统下，通过IOCP实现。<br>在Linux系统下，没有，因为Linux系统下的AIO底层仍是epoll。<br>（个人猜测，这也是为什么Netty使用了NIO，而没有使用AIO）</p>
          </div>

<h1 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h1><p>以对话的形式讲述，比较易于理解<br><a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect" target="_blank" rel="noopener">漫话：如何给女朋友解释什么是Linux的五种IO模型？</a></p>
<p>数据的内核态，用户态，这篇文章也有讲到，同时介绍了高效的数据传输方式：zero-copy<br><a href="https://blog.csdn.net/u013256816/article/details/52589524" target="_blank" rel="noopener">zero-copy</a></p>
]]></content>
      <categories>
        <category>IO</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript模拟post表单提交</title>
    <url>/blog/2018/11/11/javascript-post-form/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天遇到一个问题，我在使用spring-security的时候，配置了登出链接：<code>&lt;logout logout-url=&quot;/logout&quot; logout-success-url=&quot;/&quot; /&gt;</code>.但是登出的button每当点击的时候就会报异常：服务器没有对应的方法（/logout）。</p>
<a id="more"></a>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>因为在spring-security中默认开启了csrf，所以在提交表单的时候需要用一个隐藏button提交token，就以注册页面举例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">role</span>=<span class="string">"form"</span> <span class="attr">action</span>=<span class="string">"$&#123;basePath&#125;/register"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">id</span>=<span class="string">"form"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"$&#123;_csrf.parameterName&#125;"</span> <span class="attr">value</span>=<span class="string">"$&#123;_csrf.token&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"password"</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以对于登出接口也是一样，需要以post方式提交，并且加入token。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>专门写一个form表单，映射到退出的button上，这样不是不可以，但是不美观（对于前端技术，没有深入研究）。<br>所以我就想写一个js脚本，提交post请求，这个button就来调一下这个js函数就行了。<br>那么我的js脚本如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postRequest</span>(<span class="params">path, params, method</span>) </span>&#123;</span><br><span class="line">    method = method || <span class="string">"post"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> form = <span class="built_in">document</span>.createElement(<span class="string">"form"</span>);</span><br><span class="line">    form.setAttribute(<span class="string">"method"</span>, method);</span><br><span class="line">    form.setAttribute(<span class="string">"action"</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">        <span class="keyword">if</span>(params.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">var</span> hiddenField = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span><br><span class="line">            hiddenField.setAttribute(<span class="string">"type"</span>, <span class="string">"hidden"</span>);</span><br><span class="line">            hiddenField.setAttribute(<span class="string">"name"</span>, key);</span><br><span class="line">            hiddenField.setAttribute(<span class="string">"value"</span>, params[key]);</span><br><span class="line"></span><br><span class="line">            form.appendChild(hiddenField);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(form);</span><br><span class="line">    form.submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要登出的地方，进行如下调用即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:postRequest('$&#123;basePath&#125;/logout', &#123;'$&#123;_csrf.parameterName&#125;': '$&#123;_csrf.token&#125;'&#125;);"</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>OK，搞定。<br>如有不对之处，还请各位赐教。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>csrf</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql blocked because of many connection errors</title>
    <url>/blog/2018/03/06/mysql-flush-hosts/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天启动服务的时候，发现有一个服务一直启动不起来，报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Caused by:</span><br><span class="line">java.sql.SQLException: null,</span><br><span class="line">message from server: "Host '192.168.0.10' is blocked because of many connection errors; unblock with 'mysqladmin flush-hosts'"</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这里的错误已经很明确了，就说某一个ip产生了大量的错误链接，然后这个IP就被锁了，如果要解除锁定，就用mysql自带的名命令’mysqladmin flush-hosts’解锁即可。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ol>
<li><p>通过提示，用命令’mysqladmin flush-hosts’。</p>
<blockquote>
<p>如果是远程机器，可以使用 :<br>mysqladmin flush-hosts -h 192.168.1.9 -P 3306 -u root -p</p>
</blockquote>
</li>
<li><p>进入mysql命令行，输入’flush hosts’也是可以的。如下图所示：</p>
<img src="/blog/2018/03/06/mysql-flush-hosts/mysql-flush-hosts-1.png" class="">
</li>
<li><p>修改max_connection_errors</p>
<blockquote>
<p>查看：show variables like ‘max_connect_errors’;<br>修改：set global max_connect_errors = 1000;<br>校验：show variables like ‘max_connect_errors’;</p>
</blockquote>
</li>
</ol>
<img src="/blog/2018/03/06/mysql-flush-hosts/mysql-flush-hosts-2.png" class="">
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>使用crond构建linux定时任务及日志查看</title>
    <url>/blog/2018/03/02/linux-crond/</url>
    <content><![CDATA[<h1 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h1><ol>
<li>新建一个定时任务配置文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ubuntu ~]# vim /etc/cron.d/myTask</span><br></pre></td></tr></table></figure>

</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><p>编辑内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ubuntu ~]# cat /etc/cron.d/myTask</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"># 将当前时间写入到log文件,一小时执行一次</span><br><span class="line">0 * * * * root echo `date` &gt;&gt; /root/date.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新载入配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ubuntu ~]# service crond reload</span><br></pre></td></tr></table></figure>
<p>搞定</p>
</li>
</ol>
<hr>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><ol>
<li><p>定时任务配置文件可以放到<code>/etc/cron.d</code>文件夹下，reload 或 restart 的时候crond服务会扫描该文件夹下的文件。</p>
</li>
<li><p>定时任务配置：<br>执行时间(cron表达式) + 执行用户 + 任务</p>
<blockquote>
<p>示例： 0 * * * * root python /root/hello.py</p>
</blockquote>
</li>
<li><p>新增或修改定时任务配置后，需要reload才能生效。</p>
</li>
<li><p>服务相关命令：<br>service crond start    //启动服务<br>service crond stop     //关闭服务<br>service crond restart  //重启服务<br>service crond reload   //重新载入配置<br>service crond status   //查看服务状态</p>
</li>
</ol>
<hr>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><ol>
<li><p>查看任务有没有运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ubuntu ~]# tail -2 /var/log/cron</span><br><span class="line">Dec 15 06:00:01 ubuntu CROND[28783]: (root) CMD (echo `date` &gt;&gt; /root/date.log)</span><br><span class="line">Dec 15 06:01:01 ubuntu CROND[28923]: (root) CMD (echo `date` &gt;&gt; /root/date.log)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果运行中报错等，会有邮件记录，在此处查看详情：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ubuntu ~]# tail -2 /var/spool/mail/root</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>crond</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>classpath和classpath*的区别</title>
    <url>/blog/2017/12/01/classpath-asterisk/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现在我们在开发一套OA系统，用到了springMVC，我们的spring相关配置文件统一放在<code>src/main/resources/spring</code> 文件夹下面，web.xml进行如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/application-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>我们现在需要用到一个定时任务管理系统，是公司另一个部门开发的，通过maven dependence的方式引入，该jar包中也有spring相关的配置文件，路径为：<code>spring/application-task</code>。但是项目启动的时候，这个配置文件却没有加载进来。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>后面将web.xml的配置修改了一下，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring/application-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我认为，classpath就是加载当前项目下的资源文件。<br>而classpath*就是加载包含jar包在内的所有依赖的资源文件。<br>后续看了源代码，继续进行深入分析，这里只是打一个标记，算是给遇到该问题的人一个出坑的思路。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
